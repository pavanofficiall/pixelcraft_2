import type { Asset } from 'grapesjs';
import { WithEditorProps } from './common';
export declare enum AssetStorageType {
    self = "self",
    cloud = "cloud"
}
export interface AssetProps {
    /**
     * The asset ID.
     */
    id?: string;
    /**
     * The asset URL.
     */
    src: string;
    /**
     * Custom asset name.
     * @example 'image.jpg'
     */
    name?: string;
    /**
     * The asset mime type, eg. `image/jpeg`.
     */
    mimeType?: string;
    /**
     * Size of the assets in bytes.
     */
    size?: number;
}
export interface AssetsConfig {
    /**
     * Choose between hosting assets on:
     * - 'self': your own self-hosted infrastructure
     * - 'cloud': using our asset cloud.
     *
     * To use 'cloud' you must provide an identity.id for your users and a project.id for your project in config.
     * @default 'self'
     */
    storageType?: `${AssetStorageType}` | AssetStorageType;
    /**
     * Provide a custom upload handler for assets.
     * The handler should return an array of uploaded assets.
     * @example
     * onUpload: async ({ files }) => {
     *   const body = new FormData();
     *   for (const file of files) {
     *     body.append('files', file);
     *   }
     *   const response = await fetch('ASSETS_UPLOAD_URL', { method: 'POST', body });
     *   const result = await response.json();
     *   // The expected result should be an array of assets, eg.
     *   // [{ src: 'ASSET_URL' }]
     *   return result;
     * },
     */
    onUpload?: (props: {
        files: File[];
    } & WithEditorProps) => Promise<AssetProps[]>;
    /**
     * Provide a custom handler for loading project assets.
     * The handler should return an array of uploaded assets.
     * @example
     * onLoad: async () => {
     *   // Load assets from your server
     *   const response = await fetch('ASSETS_LOAD_URL');
     *   const result = await response.json();
     *   // you can also provide default assets here
     *   return [ { src: 'ASSET_URL' }, ...result ];
     * }
     */
    onLoad?: (props: WithEditorProps) => Promise<AssetProps[]>;
    /**
     * Provide a custom handler for deleting assets.
     * If the handler doesn't throw any error, the assets will be removed from the asset manager.
     * @example
     * onDelete: async ({ assets }) => {
     *   const body = JSON.stringify(assets);
     *   await fetch('ASSETS_DELETE_URL', { method: 'DELETE', body });
     * }
     */
    onDelete?: (props: {
        assets: Asset[];
    } & WithEditorProps) => Promise<void>;
}
